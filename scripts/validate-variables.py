#!/usr/bin/env python3
"""
Variable reference validation for capability operations
Usage: python3 scripts/validate-variables.py [path]

Validates that all {{PLACEHOLDER}} variables in operation templates
have corresponding definitions in config.yaml or operation parameters.
"""

import yaml
import re
import sys
from pathlib import Path
from typing import Dict, List, Set, Tuple

# Common/allowed variables that don't need to be in config.yaml
# These are typically set by the engine or are standard environment variables
COMMON_VARS = {
    # Engine-provided core variables
    "AZURE_SUBSCRIPTION_ID",
    "AZURE_TENANT_ID",
    "AZURE_LOCATION",
    "AZURE_RESOURCE_GROUP",
    "AZURE_ENVIRONMENT",
    "MANAGED_IDENTITY_NAME",
    "RESOURCE_TAGS",
    "DEPLOYMENT_ID",
    "TIMESTAMP",
    "OPERATION_ID",
    "VM_NAME",
    "VM_RESOURCE_GROUP",
    "GOLDEN_IMAGE_VM_NAME",
    "TEMP_STORAGE_ACCOUNT",
    "TEMP_RESOURCE_GROUP",

    # Runtime-generated variables (not in config.yaml)
    "POWERSHELL_CONTENT",  # Generated by template engine
    "APP_MANIFEST_B64",  # Generated from applications list
    "GOLDEN_IMAGE_APPLICATIONS_CSV",  # Generated from applications list

    # Short-form aliases (config-manager.sh exports these from nested paths)
    "DISK_NAME",  # from golden_image.disk_name
    "DISK_SIZE_GB",  # from golden_image.disk_size_gb
    "GOLDEN_IMAGE_NAME",  # from golden_image.image_name
    "COMPUTE_VM_NAME",  # from session_host.vm_name
    "COMPUTE_AVAILABILITY_SET_MANAGED",  # from compute.availability_set_enabled

    # ENTRA_GROUP_* short-form aliases (from entra_id.group_*)
    "ENTRA_GROUP_USERS_STANDARD",
    "ENTRA_GROUP_USERS_STANDARD_DESCRIPTION",
    "ENTRA_GROUP_USERS_ADMINS",
    "ENTRA_GROUP_DEVICES_FSLOGIX",
    "ENTRA_GROUP_DEVICES_FSLOGIX_DESCRIPTION",
    "ENTRA_GROUP_DEVICES_NETWORK",
    "ENTRA_GROUP_DEVICES_NETWORK_DESCRIPTION",
    "ENTRA_GROUP_DEVICES_SECURITY",
    "ENTRA_GROUP_DEVICES_SECURITY_DESCRIPTION",
    "ENTRA_GROUP_DEVICES_SSO",

    # NETWORKING_* short-form aliases
    "NETWORKING_LB_NAME",  # from networking.load_balancer_name
    "NETWORKING_LB_SKU",  # Added to config.yaml (networking.load_balancer_sku)
    "NETWORKING_LB_TYPE",  # Added to config.yaml (networking.load_balancer_type)
    "NETWORKING_PUBLIC_IP_SKU",  # Added to config.yaml (networking.public_ip_sku)
    "NETWORKING_PUBLIC_IP_ALLOCATION_METHOD",  # Added to config.yaml

    # Automation service principal variables
    "AUTOMATION_SERVICE_PRINCIPAL_NAME",
    "AUTOMATION_SP_CREDENTIAL_DURATION",
    "AUTOMATION_SP_CREDENTIAL_TYPE",

    # Operation-specific parameters (passed at runtime, not in config)
    "MEMBER_ID",
    "MEMBER_EMAIL",
    "MEMBER_TYPE",
    "NIC_NAME",

    # Extended networking variables (operation-specific, not all in config)
    "NETWORKING_LB_FRONTEND_IP_NAME",
    "NETWORKING_LB_BACKEND_POOL_NAME",
    "NETWORKING_LB_ENABLE_FLOATING_IP",
    "NETWORKING_LB_PUBLIC_IP_ID",
    "NETWORKING_LB_SUBNET_ID",
    "NETWORKING_PUBLIC_IP_DOMAIN_LABEL",
    "NETWORKING_PUBLIC_IP_IDLE_TIMEOUT",
    "NETWORKING_PUBLIC_IP_VERSION",
    "NETWORKING_ROUTE_TABLE_DISABLE_BGP",
    "NETWORKING_PRIVATE_ENDPOINT_SUBNET_NAME",

    # Extended compute/VM extension variables (operation-specific)
    "COMPUTE_EXTENSION_AUTO_UPGRADE",
    "COMPUTE_EXTENSION_COMMAND",
    "COMPUTE_EXTENSION_DSC_CONFIG_URL",
    "COMPUTE_EXTENSION_PROTECTED_SETTINGS",
    "COMPUTE_EXTENSION_SCRIPT_NAME",
    "COMPUTE_EXTENSION_SCRIPT_URI",
}

# Pattern to match {{VARIABLE}} or {{VARIABLE:-default}}
VAR_PATTERN = re.compile(r'\{\{([A-Z_][A-Z0-9_]*)(:-[^}]+)?\}\}')


def load_config_variables(config_path: Path) -> Set[str]:
    """Load variables from config.yaml and convert to uppercase with underscores."""
    variables = set()

    if not config_path.exists():
        return variables

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)

        def extract_keys(d: dict, prefix: str = ''):
            """Recursively extract all keys from nested dictionary."""
            for key, value in d.items():
                full_key = f"{prefix}_{key}" if prefix else key
                # Convert to uppercase with underscores
                var_name = full_key.upper().replace('.', '_').replace('-', '_')
                variables.add(var_name)

                if isinstance(value, dict):
                    extract_keys(value, full_key)

        if data:
            extract_keys(data)

    except Exception as e:
        print(f"Warning: Could not load config.yaml: {e}", file=sys.stderr)

    return variables


def extract_variables_from_file(file_path: Path) -> Tuple[Set[str], Set[str]]:
    """
    Extract variables from operation file.
    Returns (template_vars, parameter_names)
    """
    template_vars = set()
    parameter_names = set()

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            data = yaml.safe_load(content)

        # Extract variables from template command
        if data and 'operation' in data:
            operation = data['operation']

            # Get template command
            if 'template' in operation and 'command' in operation['template']:
                command = operation['template']['command']
                matches = VAR_PATTERN.findall(command)
                for match in matches:
                    # match is tuple: (var_name, default_value_with_colon_dash)
                    var_name = match[0]
                    template_vars.add(var_name)

            # Get parameter names
            if 'parameters' in operation:
                params = operation['parameters']
                for param_type in ['required', 'optional']:
                    if param_type in params and isinstance(params[param_type], list):
                        for param in params[param_type]:
                            if isinstance(param, dict) and 'name' in param:
                                parameter_names.add(param['name'])

    except Exception as e:
        print(f"Warning: Error processing {file_path}: {e}", file=sys.stderr)

    return template_vars, parameter_names


def main():
    """Validate all operations."""
    # Determine search path
    if len(sys.argv) > 1:
        search_path = Path(sys.argv[1])
    else:
        search_path = Path('capabilities')

    if not search_path.exists():
        print(f"Error: Path '{search_path}' does not exist")
        sys.exit(1)

    config_file = Path('config.yaml')

    print("=" * 70)
    print("Variable Reference Validation")
    print("=" * 70)
    print()

    # Load config variables
    config_vars = load_config_variables(config_file)
    if config_file.exists():
        print(f"Loaded {len(config_vars)} variables from config.yaml")
    else:
        print("Warning: config.yaml not found, skipping config validation")

    # Add common variables
    allowed_vars = config_vars | COMMON_VARS
    print(f"Total allowed variables: {len(allowed_vars)}")
    print()

    # Find all operation YAML files
    if search_path.is_file():
        all_files = [search_path]
    else:
        all_files = sorted(search_path.glob('*/operations/*.yaml'))

    if not all_files:
        print(f"No operation files found in {search_path}")
        sys.exit(1)

    total_files = 0
    files_with_issues = 0
    total_undefined = 0
    undefined_vars_global = set()

    # Process each file
    for file_path in all_files:
        total_files += 1

        template_vars, parameter_names = extract_variables_from_file(file_path)

        if not template_vars:
            continue

        # Check each variable
        undefined_vars = set()
        for var in template_vars:
            # Check if it's in allowed variables
            if var in allowed_vars:
                continue

            # Check if it's a parameter name
            if var in parameter_names:
                continue

            # Variable is undefined
            undefined_vars.add(var)
            undefined_vars_global.add(var)
            total_undefined += 1

        # Report for this file
        try:
            rel_path = file_path.relative_to(Path.cwd())
        except ValueError:
            rel_path = file_path

        if undefined_vars:
            print(f"\u2717 {rel_path}")
            print("  Undefined variables:")
            for uvar in sorted(undefined_vars):
                print(f"    - {{{{{uvar}}}}}")
            print()
            files_with_issues += 1
        else:
            print(f"\u2713 {rel_path}")

    print()
    print("=" * 70)
    print("Variable Reference Validation Summary")
    print("=" * 70)
    print(f"  Total files:       {total_files}")
    print(f"  Files with issues: {files_with_issues}")
    print(f"  Undefined vars:    {len(undefined_vars_global)}")
    print()

    if files_with_issues > 0:
        print("Undefined variables across all files:")
        for var in sorted(undefined_vars_global):
            print(f"  - {{{{{var}}}}}")
        print()
        print("\033[1;33mNote: These variables should be defined in:\033[0m")
        print("  1. config.yaml (as configuration values)")
        print("  2. operation.parameters.required or .optional (as operation parameters)")
        print("  3. Added to COMMON_VARS in this script (if engine-provided)")
        print()
        sys.exit(1)
    else:
        print("\033[0;32m\u2713 All variable references are properly defined\033[0m")
        sys.exit(0)


if __name__ == '__main__':
    main()
