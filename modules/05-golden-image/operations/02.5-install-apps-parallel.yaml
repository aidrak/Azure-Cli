# ==============================================================================
# Operation: Install Applications with Parallel Downloads
# ==============================================================================
operation:
  id: "golden-image-install-apps-parallel"
  name: "Install Chrome and Adobe (Optimized)"
  description: "Download and install applications in parallel with heartbeat monitoring"

  # Duration expectations
  duration:
    expected: 480  # 8 minutes (more robust monitoring adds some overhead)
    timeout: 900   # 15 minutes
    type: "HEARTBEAT" # New type for progress tracker

  # Prerequisites (check state.json)
  requires:
    - operation: "golden-image-system-prep"
      status: "completed"

  # Validation checks (run after operation completes)
  validation:
    enabled: true
    checks:
      - type: "file_exists"
        path: "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"
        description: "Chrome executable installed"

      - type: "file_exists"
        path: "C:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\AcroRd32.exe"
        description: "Adobe Reader executable installed"
        alternative_path: "C:\\Program Files\\Adobe\\Acrobat DC\\Acrobat\\Acrobat.exe"

  # Template command (variables substituted at runtime)
  template:
    type: "az-vm-run-command"
    command: |
      az vm run-command create \
        --resource-group "{{AZURE_RESOURCE_GROUP}}" \
        --name "{{GOLDEN_IMAGE_TEMP_VM_NAME}}" \
        --command-id RunPowerShellScript \
        --scripts "@modules/05-golden-image/operations/02.5-install-apps-parallel.ps1" \
        --output json > artifacts/outputs/golden-image-install-apps-parallel.json

  # PowerShell script with parallel download optimization
  powershell:
    file: "02.5-install-apps-parallel.ps1"
    content: |
      [START]
      # ============================================================================== 
      # Helper Functions
      # ============================================================================== 
      function Start-Heartbeat {
          param(
              [string]$AppName,
              [int]$ParentProcessId
          )
          $scriptBlock = {
              param($AppName, $ParentProcessId)

              $logDir = "C:\DeployLogs"
              if (-not (Test-Path $logDir)) {
                  New-Item -Path $logDir -ItemType Directory -Force | Out-Null
              }
              $heartbeatFile = "$logDir\$($AppName).heartbeat"
              $parentProcess = Get-Process -Id $ParentProcessId -ErrorAction SilentlyContinue

              while ($parentProcess) {
                  $timestamp = [datetime]::UtcNow.ToString("o")
                  Set-Content -Path $heartbeatFile -Value $timestamp
                  Start-Sleep -Seconds 30
                  $parentProcess = Get-Process -Id $ParentProcessId -ErrorAction SilentlyContinue
              }
          }
          return Start-Job -ScriptBlock $scriptBlock -ArgumentList $AppName, $ParentProcessId
      }

      # ============================================================================== 
      # Main Execution
      # ============================================================================== 
      Write-Host "[START] Parallel Application Installation with Heartbeat"

      # Configuration
      $config = @{
          LogDir = "C:\DeployLogs"
          TempDir = "C:\Temp"
          Apps = @(
              @{
                  Name = "Chrome"
                  Type = "Download"
                  Url = "https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise64.msi"
                  OutFile = "C:\Temp\Chrome.msi"
              },
              @{
                  Name = "AdobeReader"
                  Type = "Download"
                  Url = "https://ardownload2.adobe.com/pub/adobe/reader/win/AcrobatDC/2300320201/AcroRdrDC2300320201_en_US.exe"
                  OutFile = "C:\Temp\AdobeReader.exe"
              },
              @{
                  Name = "ChromeInstall"
                  Type = "Install"
                  DependsOn = "Chrome" # Depends on the download
                  FilePath = "msiexec.exe"
                  Arguments = "/i `"C:\Temp\Chrome.msi`" /quiet /norestart /log `"C:\DeployLogs\ChromeInstall.log`""
                  SuccessCodes = @(0, 3010)
              },
              @{
                  Name = "AdobeReaderInstall"
                  Type = "Install"
                  DependsOn = "AdobeReader"
                  FilePath = "C:\Temp\AdobeReader.exe"
                  Arguments = "/sAll /rs /msi EULA_ACCEPT=YES"
                  SuccessCodes = @(0)
              }
          )
      }

      # Initialize directories
      if (-not (Test-Path $config.LogDir)) { New-Item -Path $config.LogDir -ItemType Directory -Force | Out-Null }
      if (-not (Test-Path $config.TempDir)) { New-Item -Path $config.TempDir -ItemType Directory -Force | Out-Null }

      $allJobs = @{} # Hashtable to store all job info

      try {
          # ============================================================================== 
          # Phase 1: Start All Parallel Jobs (Downloads and Installations)
          # ============================================================================== 
          Write-Host "[PROGRESS] Phase 1: Starting all jobs..."

          foreach ($app in $config.Apps) {
              # If it's an install job, skip it for now. We handle it after downloads.
              if ($app.Type -eq "Install") { continue }

              # --- DOWNLOAD JOBS ---
              $job = Start-Job -ScriptBlock {
                  param($app, $parentPid)
                  $hbJob = . "Start-Heartbeat" -AppName $app.Name -ParentProcessId $parentPid

                  try {
                      Write-Host "[$($app.Name)] Starting download from $($app.Url)"
                      Invoke-WebRequest -Uri $app.Url -OutFile $app.OutFile -UseBasicParsing -TimeoutSec 300 -ErrorAction Stop
                      Write-Host "[$($app.Name)] Download completed."
                      return @{ Status = 'Success' }
                  } catch {
                      Write-Host "[$($app.Name)] ERROR: $($_.Exception.Message)"
                      return @{ Status = 'Failed'; Error = $_.Exception.Message }
                  } finally {
                      Stop-Job -Job $hbJob
                      Remove-Job -Job $hbJob
                  }
              } -ArgumentList $app, $PID
              # Pass heartbeat function definition to the job's scope
              $job.PSJobTypeName = 'BackgroundJob'
              $job.InitializationScript = ${function:Start-Heartbeat}

              $allJobs[$app.Name] = @{ Job = $job; Type = $app.Type }
          }

          # ============================================================================== 
          # Phase 2: Monitor Downloads, then start Installations
          # ============================================================================== 
          Write-Host "[PROGRESS] Phase 2: Monitoring downloads..."
          $downloadJobs = $allJobs.GetEnumerator() | Where-Object { $_.Value.Type -eq "Download" }
          
          while($downloadJobs | Where-Object { $_.Value.Job.State -eq 'Running' }) {
              Start-Sleep -Seconds 15
              Write-Host "[MONITOR] Waiting for $($downloadJobs.Count) download(s) to complete..."
          }

          $failedDownloads = @()
          foreach($item in $downloadJobs) {
              $result = Receive-Job -Job $item.Value.Job
              if($result.Status -ne 'Success') {
                  Write-Host "[ERROR] Download job $($item.Name) failed: $($result.Error)"
                  $failedDownloads += $item.Name
              } else {
                  Write-Host "[SUCCESS] Download job $($item.Name) completed."
              }
              Remove-Job -Job $item.Value.Job
          }
          
          if ($failedDownloads.Count -gt 0) {
              throw "One or more downloads failed: $($failedDownloads -join ', ')"
          }
          Write-Host "[SUCCESS] All downloads completed."


          Write-Host "[PROGRESS] Starting install jobs..."
          foreach ($app in $config.Apps) {
              if ($app.Type -eq "Download") { continue }

              # Check dependency
              if ($app.DependsOn -and $failedDownloads.Contains($app.DependsOn)) {
                  Write-Host "[SKIP] Skipping install for $($app.Name) because dependency $($app.DependsOn) failed to download."
                  continue
              }

              # --- INSTALL JOBS ---
              $job = Start-Job -ScriptBlock {
                  param($app, $parentPid)
                  $hbJob = . "Start-Heartbeat" -AppName $app.Name -ParentProcessId $parentPid
                  
                  try {
                      Write-Host "[$($app.Name)] Starting installation..."
                      $process = Start-Process -FilePath $app.FilePath -ArgumentList $app.Arguments -Wait -PassThru -ErrorAction Stop
                      
                      if ($app.SuccessCodes -contains $process.ExitCode) {
                          Write-Host "[$($app.Name)] Installation completed with success code: $($process.ExitCode)."
                          return @{ Status = 'Success' }
                      } else {
                          Write-Host "[$($app.Name)] ERROR: Installation failed with exit code: $($process.ExitCode)."
                          return @{ Status = 'Failed'; Error = "Exit code $($process.ExitCode)" }
                      }
                  } catch {
                      Write-Host "[$($app.Name)] ERROR: $($_.Exception.Message)"
                      return @{ Status = 'Failed'; Error = $_.Exception.Message }
                  } finally {
                      Stop-Job -Job $hbJob
                      Remove-Job -Job $hbJob
                  }
              } -ArgumentList $app, $PID
              $job.PSJobTypeName = 'BackgroundJob'
              $job.InitializationScript = ${function:Start-Heartbeat}

              $allJobs[$app.Name] = @{ Job = $job; Type = $app.Type }
          }

          # ============================================================================== 
          # Phase 3: Monitor Installations
          # ============================================================================== 
          Write-Host "[PROGRESS] Phase 3: Monitoring installations..."
          $installJobs = $allJobs.GetEnumerator() | Where-Object { $_.Value.Type -eq "Install" }

          while($installJobs | Where-Object { $_.Value.Job.State -eq 'Running' }) {
              Start-Sleep -Seconds 15
              Write-Host "[MONITOR] Waiting for $($installJobs.Count) installation(s) to complete..."
          }

          $failedInstalls = @()
          foreach($item in $installJobs) {
              $result = Receive-Job -Job $item.Value.Job
              if($result.Status -ne 'Success') {
                  Write-Host "[ERROR] Install job $($item.Name) failed: $($result.Error)"
                  $failedInstalls += $item.Name
              } else {
                  Write-Host "[SUCCESS] Install job $($item.Name) completed."
              }
              Remove-Job -Job $item.Value.Job
          }

          if ($failedInstalls.Count -gt 0) {
              throw "One or more installations failed: $($failedInstalls -join ', ')"
          }

          # ============================================================================== 
          # Summary
          # ============================================================================== 
          Write-Host "[SUCCESS] All applications installed successfully."
          exit 0

      } catch {
          Write-Host "[ERROR] Fatal exception occurred: $($_.Exception.Message)"
          Write-Host "[ERROR] Stack trace: $($_.ScriptStackTrace)"
          exit 1
      }
  # Self-healing: Previous fixes applied to this template
  fixes:
    # Fixes will be added here automatically when errors occur