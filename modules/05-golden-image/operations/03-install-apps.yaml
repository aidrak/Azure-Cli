# ==============================================================================
# Operation: Install Applications Dynamically
# ==============================================================================
operation:
  id: "golden-image-03-install-apps"
  name: "03: Install Applications"
  description: "Install all selected applications in parallel with heartbeat monitoring"

  duration:
    expected: 1200 # 20 minutes
    timeout: 2400 # 40 minutes
    type: "HEARTBEAT"

  requires:
    - operation: "golden-image-02-system-prep"
      status: "completed"

  template:
    type: "powershell-vm-command"
    command: |
      pwsh -NoProfile -NonInteractive -Command {
        # Extract PowerShell content from YAML (template engine injects this)
        $scriptContent = @'
{{POWERSHELL_CONTENT}}
'@

        # Write to temporary file
        $tempScript = "/tmp/golden-image-03-install-apps-$([guid]::NewGuid()).ps1"
        $scriptContent | Out-File -FilePath $tempScript -Encoding UTF8

        try {
          # Execute via az vm run-command with parameters
          az vm run-command invoke `
            --resource-group "{{AZURE_RESOURCE_GROUP}}" `
            --name "{{GOLDEN_IMAGE_TEMP_VM_NAME}}" `
            --command-id RunPowerShellScript `
            --scripts "@$tempScript" `
            --parameters AppNames='{{GOLDEN_IMAGE_APPLICATIONS_CSV}}' ManifestB64='{{APP_MANIFEST_B64}}' `
            --output json > artifacts/outputs/golden-image-install-apps.json
        } finally {
          # Cleanup temp file
          if (Test-Path $tempScript) {
            Remove-Item -Path $tempScript -Force -ErrorAction SilentlyContinue
          }
        }
      }

  powershell:
    file: "03-install-apps.ps1"
    content: |
      [CmdletBinding()]
      param(
          [string]$AppNames,
          [string]$ManifestB64  # Base64-encoded JSON manifest
      )

      # ==============================================================================
      # Helper Functions
      # ==============================================================================
      function Start-Heartbeat {
          param([string]$AppName, [int]$ParentProcessId)
          $scriptBlock = {
              param($AppName, $ParentProcessId)
              $logDir = "C:\DeployLogs"
              if (-not (Test-Path $logDir)) { New-Item -Path $logDir -ItemType Directory -Force | Out-Null }
              $heartbeatFile = "$logDir\$($AppName).heartbeat"
              $parentProcess = Get-Process -Id $ParentProcessId -ErrorAction SilentlyContinue
              while ($parentProcess) {
                  [datetime]::UtcNow.ToString("o") | Set-Content -Path $heartbeatFile
                  Start-Sleep -Seconds 30
                  $parentProcess = Get-Process -Id $ParentProcessId -ErrorAction SilentlyContinue
              }
          }
          return Start-Job -ScriptBlock $scriptBlock -ArgumentList $AppName, $ParentProcessId
      }

      # ==============================================================================
      # Main Execution
      # ==============================================================================
      Write-Host "[START] Dynamic Application Installation Engine"

      $LogDir = "C:\DeployLogs"
      $TempDir = "C:\Temp"
      if (-not (Test-Path $LogDir)) { New-Item -Path $LogDir -ItemType Directory -Force | Out-Null }
      if (-not (Test-Path $TempDir)) { New-Item -Path $TempDir -ItemType Directory -Force | Out-Null }

      try {
          # Decode and parse manifest from base64 JSON (no external modules needed)
          if ([string]::IsNullOrWhiteSpace($ManifestB64)) {
              throw "ManifestB64 parameter is required but was not provided"
          }
          Write-Host "[INFO] Decoding manifest from base64 JSON..."
          $jsonString = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($ManifestB64))
          $manifest = $jsonString | ConvertFrom-Json

          # Parse inputs
          $selectedAppNames = $AppNames -split ',' | ForEach-Object { $_.Trim() }

          $appsToProcess = $selectedAppNames | ForEach-Object {
              $appNameKey = $_
              $appConfig = $manifest.PSObject.Properties | Where-Object { $_.Name -eq $appNameKey } | Select-Object -First 1 -ExpandProperty Value
              if ($appConfig) {
                  # Add the key name to the object itself for easier reference
                  $appConfig | Add-Member -MemberType NoteProperty -Name "Key" -Value $appNameKey -Force
                  return $appConfig
              } else {
                  Write-Warning "[SKIP] Application '$appNameKey' not found in manifest."
              }
          }

          if ($appsToProcess.Count -eq 0) {
              Write-Host "[SUCCESS] No applications selected for installation."
              exit 0
          }

          Write-Host "[INFO] The following applications will be installed:"
          $appsToProcess | ForEach-Object { Write-Host "- $($_.name)" }

          # --- STAGE 1: DOWNLOADS ---
          Write-Host "[PROGRESS] Stage 1/3: Starting Downloads..."
          $downloadJobs = @()
          foreach ($app in $appsToProcess) {
              if (-not $app.source_type -or $app.source_type -ne 'Url') {
                  if ($app.source_type -and $app.source_type -ne 'Url') {
                      Write-Host "[SKIP] $($app.Key): source_type is '$($app.source_type)', skipping download"
                  }
                  continue
              }
              $job = Start-Job -InitializationScript ${function:Start-Heartbeat} -ScriptBlock {
                  param($app, $parentPid)
                  $hbJob = Start-Heartbeat -AppName "$($app.Key)-Download" -ParentProcessId $parentPid
                  try {
                      Write-Host "[$($app.name)] Downloading from $($app.url)..."
                      Invoke-WebRequest -Uri $app.url -OutFile $app.outfile -UseBasicParsing -TimeoutSec 600 -ErrorAction Stop
                      return @{ Status = 'Success'; AppKey = $app.Key }
                  } catch {
                      return @{ Status = 'Failed'; AppKey = $app.Key; Error = $_.Exception.Message }
                  } finally {
                      if ($hbJob) {
                          Stop-Job -Job $hbJob -ErrorAction SilentlyContinue
                          Remove-Job -Job $hbJob -ErrorAction SilentlyContinue
                      }
                  }
              } -ArgumentList $app, $PID
              $downloadJobs += $job
          }
          
          Write-Host "[MONITOR] Waiting for $($downloadJobs.Count) download(s) to complete..."
          $downloadJobs | Wait-Job | Out-Null
          $failedApps = @()
          $downloadJobs | ForEach-Object {
              $result = Receive-Job $_
              if ($result.Status -ne 'Success') {
                  Write-Error "[$($result.AppKey)] Download failed: $($result.Error)"
                  $failedApps += $result.AppKey
              } else {
                  Write-Host "[SUCCESS] $($result.AppKey) downloaded successfully."
              }
              Remove-Job $_
          }

          # --- STAGE 2: EXTRACTIONS (for ZIP files) ---
          Write-Host "[PROGRESS] Stage 2/3: Starting Extractions..."
          $unzipJobs = @()
          foreach ($app in $appsToProcess) {
              if ($failedApps.Contains($app.Key)) { continue }
              if (-not $app.source_format -or $app.source_format -ne 'zip') {
                  if ($app.source_format -and $app.source_format -ne 'zip') {
                      Write-Host "[SKIP] $($app.Key): source_format is '$($app.source_format)', skipping extraction"
                  }
                  continue
              }
              $job = Start-Job -InitializationScript ${function:Start-Heartbeat} -ScriptBlock {
                  param($app, $parentPid)
                  $hbJob = Start-Heartbeat -AppName "$($app.Key)-Unzip" -ParentProcessId $parentPid
                  try {
                      Write-Host "[$($app.name)] Extracting $($app.outfile)..."
                      Expand-Archive -Path $app.outfile -DestinationPath $app.unzip_dir -Force
                      return @{ Status = 'Success'; AppKey = $app.Key }
                  } catch {
                      return @{ Status = 'Failed'; AppKey = $app.Key; Error = $_.Exception.Message }
                  } finally {
                      if ($hbJob) {
                          Stop-Job -Job $hbJob -ErrorAction SilentlyContinue
                          Remove-Job -Job $hbJob -ErrorAction SilentlyContinue
                      }
                  }
              } -ArgumentList $app, $PID
              $unzipJobs += $job
          }

          if ($unzipJobs.Count -gt 0) {
              Write-Host "[MONITOR] Waiting for $($unzipJobs.Count) extraction(s) to complete..."
              $unzipJobs | Wait-Job | Out-Null
              $unzipJobs | ForEach-Object {
                  $result = Receive-Job $_
                  if ($result.Status -ne 'Success') {
                      Write-Error "[$($result.AppKey)] Extraction failed: $($result.Error)"
                      $failedApps += $result.AppKey
                  } else {
                      Write-Host "[SUCCESS] $($result.AppKey) extracted successfully."
                  }
                  Remove-Job $_
              }
          }
          
          # --- STAGE 3: INSTALLATIONS ---
          Write-Host "[PROGRESS] Stage 3/3: Starting Installations..."
          $installJobs = @()
          foreach ($app in $appsToProcess) {
              if ($failedApps.Contains($app.Key)) { continue }
              $job = Start-Job -InitializationScript ${function:Start-Heartbeat} -ScriptBlock {
                  param($app, $parentPid)
                  $hbJob = Start-Heartbeat -AppName "$($app.Key)-Install" -ParentProcessId $parentPid
                  try {
                      # Handle null/undefined properties with safe defaults
                      $outfileValue = if ($app.outfile) { $app.outfile } else { "" }
                      $unzipDirValue = if ($app.unzip_dir) { $app.unzip_dir } else { "" }

                      $cmd = $app.install_command.Replace('{outfile}', $outfileValue).Replace('{unzip_dir}', $unzipDirValue)
                      $args = $app.install_args.Replace('{outfile}', $outfileValue).Replace('{unzip_dir}', $unzipDirValue).Replace('{logdir}', "C:\DeployLogs")

                      Write-Host "[$($app.name)] Installing with command: $cmd $args"
                      $process = Start-Process -FilePath $cmd -ArgumentList $args -Wait -PassThru -ErrorAction Stop

                      # Default to success code 0 if not specified
                      $validCodes = if ($app.success_codes) { $app.success_codes } else { @(0) }
                      if ($validCodes -contains $process.ExitCode) {
                          return @{ Status = 'Success'; AppKey = $app.Key }
                      } else {
                          return @{ Status = 'Failed'; AppKey = $app.Key; Error = "Installer failed with exit code $($process.ExitCode)" }
                      }
                  } catch {
                      return @{ Status = 'Failed'; AppKey = $app.Key; Error = $_.Exception.Message }
                  } finally {
                      if ($hbJob) {
                          Stop-Job -Job $hbJob -ErrorAction SilentlyContinue
                          Remove-Job -Job $hbJob -ErrorAction SilentlyContinue
                      }
                  }
              } -ArgumentList $app, $PID
              $installJobs += $job
          }
          
          Write-Host "[MONITOR] Waiting for $($installJobs.Count) installation(s) to complete..."
          $installJobs | Wait-Job | Out-Null
          $installJobs | ForEach-Object {
              $result = Receive-Job $_
              if ($result.Status -ne 'Success') {
                  Write-Error "[$($result.AppKey)] Installation failed: $($result.Error)"
                  $failedApps += $result.AppKey
              } else {
                  Write-Host "[SUCCESS] $($result.AppKey) installed successfully."
              }
              Remove-Job $_
          }

          # Final Summary
          if ($failedApps.Count -gt 0) {
              throw "One or more applications failed to install: $($failedApps -join ', ')"
          }

          Write-Host "[SUCCESS] All selected applications installed successfully."
          exit 0

      } catch {
          Write-Error "[FATAL] A critical error occurred. $($_.Exception.Message)"
          exit 1
      }
