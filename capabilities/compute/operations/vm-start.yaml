# ==============================================================================
# Capability Operation: Start Virtual Machine
# Operation ID: 35
# ==============================================================================

operation:
  id: "vm-start"
  name: "Start Virtual Machine"
  description: "Start a stopped Azure Virtual Machine and wait for it to reach running state"

  capability: "compute"
  operation_mode: "modify"
  resource_type: "Microsoft.Compute/virtualMachines"

  # Duration expectations
  duration:
    expected: 120
    timeout: 300
    type: "WAIT"

  # Parameters
  parameters:
    required:
      - name: "vm_name"
        type: "string"
        description: "Name of the virtual machine"
        validation: "^[a-zA-Z0-9][a-zA-Z0-9-]{0,63}$"
      - name: "resource_group"
        type: "string"
        description: "Azure resource group name"
    optional:
      - name: "wait_for_ready"
        type: "boolean"
        description: "Wait for VM to reach ready state with running status"
        default: "true"
      - name: "max_wait_time"
        type: "integer"
        description: "Maximum time in seconds to wait for VM to start"
        default: "300"
      - name: "check_interval"
        type: "integer"
        description: "Interval in seconds between status checks"
        default: "15"

  # Validation checks
  validation:
    pre_checks:
      - type: "resource_exists"
        resource_type: "Microsoft.Compute/virtualMachines"
        resource_name: "{{vm_name}}"
        error_message: "Virtual machine '{{vm_name}}' not found"

    post_checks:
      - type: "provisioning_state"
        expected: "Succeeded"
        timeout: 300

  # Idempotency
  idempotency:
    enabled: true
    detection_method: "azure_check"
    check_command: |
      az vm get-instance-view \
        --name "{{vm_name}}" \
        --resource-group "{{resource_group}}" \
        --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" \
        --output tsv 2>/dev/null | grep -q "running"

  # Template command
  template:
    type: "powershell-local"
    command: |
      cat > /tmp/compute-vm-start-wrapper.ps1 << 'PSWRAPPER'
      $ErrorActionPreference = 'Stop'

      $vmName = "{{vm_name}}"
      $resourceGroup = "{{resource_group}}"
      $waitForReady = [System.Convert]::ToBoolean("{{wait_for_ready}}")
      $maxWaitTime = [int]"{{max_wait_time}}"
      $checkInterval = [int]"{{check_interval}}"

      Write-Host "[START] Starting 'Start Virtual Machine' operation..."

      Write-Host "[PROGRESS] Retrieving VM information..."
      $vm = az vm get-instance-view `
        --name $vmName `
        --resource-group $resourceGroup `
        --output json 2>&1 | ConvertFrom-Json

      if (-not $vm) {
        Write-Host "[ERROR] Virtual machine '$vmName' not found"
        exit 1
      }

      $powerState = $vm.instanceView.statuses | Where-Object { $_.code -like "PowerState/*" } | Select-Object -First 1
      $currentState = $powerState.code -replace "PowerState/", ""

      if ($currentState -eq "running") {
        Write-Host "[SUCCESS] Virtual machine '$vmName' is already running"
        Write-Host "[SUCCESS] - Current state: $currentState"
        exit 0
      }

      Write-Host "[PROGRESS] Current power state: $currentState"
      Write-Host "[PROGRESS] Starting virtual machine '$vmName'..."

      az vm start `
        --name $vmName `
        --resource-group $resourceGroup `
        --no-wait `
        --output none

      if ($LASTEXITCODE -ne 0) {
        Write-Host "[ERROR] Failed to start VM"
        exit 1
      }

      if ($waitForReady) {
        Write-Host "[PROGRESS] Waiting for VM to reach running state (timeout: $maxWaitTime seconds)..."
        $startTime = Get-Date
        $pollCount = 0

        while ((Get-Date) -lt $startTime.AddSeconds($maxWaitTime)) {
          $pollCount++
          Start-Sleep -Seconds $checkInterval

          $vmStatus = az vm get-instance-view `
            --name $vmName `
            --resource-group $resourceGroup `
            --output json 2>&1 | ConvertFrom-Json

          if (-not $vmStatus) {
            Write-Host "[PROGRESS] Poll $pollCount: VM query failed, retrying..."
            continue
          }

          $powerState = $vmStatus.instanceView.statuses | Where-Object { $_.code -like "PowerState/*" } | Select-Object -First 1
          if ($powerState) {
            $state = $powerState.code -replace "PowerState/", ""
            Write-Host "[PROGRESS] Poll $pollCount: Power state = $state"

            if ($state -eq "running") {
              Write-Host "[PROGRESS] VM is now in running state"

              $provisioningState = $vmStatus.provisioningState
              Write-Host "[PROGRESS] Provisioning state: $provisioningState"

              if ($provisioningState -eq "Succeeded") {
                Write-Host "[SUCCESS] Virtual machine '$vmName' started successfully"
                Write-Host "[SUCCESS] - Final state: $state"
                Write-Host "[SUCCESS] - Provisioning state: $provisioningState"
                exit 0
              }
            }
          }
        }

        Write-Host "[ERROR] VM did not reach running state within $maxWaitTime seconds"
        exit 1
      } else {
        Write-Host "[SUCCESS] Start command sent to virtual machine '$vmName'"
        Write-Host "[SUCCESS] - Proceeding without waiting for ready state"
        exit 0
      }
      PSWRAPPER
      pwsh -NoProfile -NonInteractive -File /tmp/compute-vm-start-wrapper.ps1
      rm -f /tmp/compute-vm-start-wrapper.ps1

  # Rollback
  rollback:
    enabled: true
    steps:
      - name: "Stop Virtual Machine"
        description: "Stop the started virtual machine to restore previous state"
        command: |
          az vm stop \
            --name "{{vm_name}}" \
            --resource-group "{{resource_group}}" \
            --no-wait
        continue_on_error: true

  # Self-healing
  fixes: []
